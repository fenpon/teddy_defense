using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Photon.Pun;

public class animation_time_controller : StateMachineBehaviour {
    //서버와의 동기화를 위해 애니메이션 타이머 콘트롤러를 직접 만들었습니다.
    //플레이타임 지정하는 알고리즘은 30fps 기준으로 제작했습니다. 애니메이션 제작은 30프레임으로 해주세여
    // OnStateEnter is called when a transition starts and the state machine starts to evaluate this state
    public bool is_loop = false;
    public bool play_time_related = false;

    public int play_time_related_type = 0; 
    //0일반 시간 개념으로 30fps 1초 기준으로 
    //1 특정 시간대(프레임)를 기준으로 공격판정같은거  play_time_related = true 일때만  주로 공격 판정할때 쓰면 편함

    public int pivot_fps = 0; // play_tme_related_type = 1일때 기준 fps

    protected int frame = 0;
    protected bool is_action = false;
    protected bool is_demage = false;
    protected PhotonView photon_view = null;
    
    protected float now_time = 0f;

    protected bool is_fin = false;
    protected int prev_ani_type = 0;

    // play_tme_related_type = 1일때
    protected float pivot_length = 0f;// 피벗의 길이
    protected float total_length = 0f;//애니메이션 w전체 길이

    protected bool is_pass_to_pivot = false;//
    protected Animator Prev_animator = null;

    float Modulation = 0f;//변조값 노멀라이즈용 값
    float normalisze_pivot_length = 0f;// 피벗 길이 정규화한거 30프레임 기준으로
    //float real_fps = 0f;//실제 실행하는 fps 실제 실행시간을 구하기위함 //실제 실행 시간을 알고 싶으면 주석처리를 해제하시오

    protected virtual void master_update(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)//update
    {

    }
    protected virtual void master_ani_end(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)//애니메이션 루프 하나 끝났을때
    {

    }

    public virtual void Re_Play_Ani()//애니메이션 다시 시작하는 기능
    {
        if (Prev_animator != null)
        {
            //Debug.LogWarning("Re_Play_Ani");
            is_fin = false;
            Prev_animator.SetFloat("play_time", 0);
            now_time = 0;
            frame = 0;
            //real_fps = 0f;//실제 실행 시간을 알고 싶으면 주석처리를 해제하시오
            is_action = false;
            is_demage = false;
            prev_ani_type = Prev_animator.GetInteger("ani_type");
            // current_animation_time_gap = stateInfo.length / 30;
            if (play_time_related_type == 1)
            {


                pivot_length = pivot_fps / 30f; // 20/ 30[유니티 애니메이션 길이1 기준 30fps]  =  0.666 // 피벗 길이
                Modulation = 1f / total_length;//1/0.733 = 1.3642

                normalisze_pivot_length = pivot_length * Modulation; // 정규화 피벗

            }
            is_pass_to_pivot = false;
        }
    }


    override public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {
       
        if (PhotonNetwork.IsMasterClient)//애니메이션 끝나고 플레이 타임 0으로 교체함.
        {
            
            is_fin = false;

            if (animator.gameObject.GetComponent<NPC_play_default_system>() != null)
            {
                animator.gameObject.GetComponent<NPC_play_default_system>().set_animator_class(this);
            }
                
            Prev_animator = animator;
            Prev_animator.SetFloat("play_time", 0);
            now_time = 0;
            frame = 0;
            //real_fps = 0f;//실제 실행 시간을 알고 싶으면 주석처리를 해제하시오
            is_action = false;
            is_demage = false;
            prev_ani_type = Prev_animator.GetInteger("ani_type");
            // current_animation_time_gap = stateInfo.length / 30;
            if(play_time_related_type == 1)
            {
                
                total_length = stateInfo.length; // 22 / 30[유니티 애니메이션 길이1 기준 30fps]  =  0.733 // 현재 애니메이션 실제 총길이
                pivot_length = pivot_fps / 30f; // 20/ 30[유니티 애니메이션 길이1 기준 30fps]  =  0.666 // 피벗 길이
                Modulation = 1f / total_length;//1/0.733 = 1.3642
               
                normalisze_pivot_length = pivot_length * Modulation; // 정규화 피벗 //0.666*1.3642 [Modulation] = 0.9085

            }
            is_pass_to_pivot = false;
        }
     
    }
    
    // OnStateUpdate is called on each Update frame between OnStateEnter and OnStateExit callbacks
    
    override public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {

        if (PhotonNetwork.IsMasterClient)//애니메이션 끝나고 플레이 타임 0으로 교체함.
        {

            // if(!stateInfo.IsName("Idle"))
            //{
            //Debug.Log("frame : " + frame);
            //}

           

            if (now_time >= 1f)
            {
                if (is_loop) 
                {
                    //stateInfo.normalizedTime
                    //if (!stateInfo.IsName("Idle"))
                    //{
                       // Debug.Log("end");
                    //}
                    animator.SetFloat("play_time", 0);
                    now_time = 0f;
                    //real_fps = 0f;//실제 실행 시간을 알고 싶으면 주석처리를 해제하시오
                    frame = 0;
                    is_action = false;
                    is_demage = false;
                    is_pass_to_pivot = false;
                }
                else
                {
                    if (!is_fin)
                    {
                        is_fin = true;
                        //animator.SetTrigger("wait");
                        if (animator.gameObject.GetComponent<enemy_ai>() != null)
                        {
                            animator.gameObject.GetComponent<enemy_ai>().ani_pose_fin();
                        }
                        else if (animator.gameObject.GetComponent<NPC_play_default_system>() != null)
                        {
                            animator.gameObject.GetComponent<NPC_play_default_system>().ani_pose_fin();
                        }
                    }
                }
                master_ani_end(animator, stateInfo, layerIndex);

            }
            else
            {
                if (play_time_related)
                {
                    if (  animator.gameObject.GetComponent<NPC_play_default_system>()  != null)
                    {
                        if (play_time_related_type == 1)
                        {
                            
                            float calc_length = animator.gameObject.GetComponent<NPC_play_default_system>().get_now_ani_total_time() / pivot_length;//(0.5[애니메이션 시간 총길이를 변조할 값 여기서 0.363초 == 11 fps 0.363]/ 22fps 0.733 ) = 0.5
                            now_time +=  ( Modulation * Time.deltaTime)/ calc_length;//변조값 1.3642*0.033(현재 fps가 30프레임이라 한프레임당 속도가 이정도라 가정) / 0.5 (calc_length)
                                                                                     //real_fps += Time.deltaTime;//실제 실행 시간을 알고 싶으면 주석처리를 해제하시오

                            //Debug.LogWarning(" P : "+real_fps);//실제 실행 시간을 알고 싶으면 주석처리를 해제하시오
                            //이값들은 예제입니다.

                            //시간 별로 실행되는 애니메이션은 이 라인으로 넘기세요 실행시간을 지정하여 할수있습니다.(공격 모션등의 판정은 이 라인이 좋습니다.)

                            if (now_time >= normalisze_pivot_length)
                            {
                             
                                //현재 기준 fps 점을 통과함..
                                if (!is_pass_to_pivot)
                                {
                                    int ani_type = animator.GetInteger("ani_type");
                                    is_pass_to_pivot = true;
                                    animator.gameObject.GetComponent<NPC_play_default_system>().animation_pass_to_pivot(ani_type);
                                }
                               
                            }
                            animator.SetFloat("play_time", now_time);
                            
                        }
                        else
                        {
                            now_time += (1f / animator.gameObject.GetComponent<NPC_play_default_system>().get_now_ani_total_time()) * Time.deltaTime;
                            //이값들은 예제입니다.
                            //(1 / 2[애니메이션 시간 총길이를 변조할 값 여기서 2초 == 60 fps] )*0.03333333333[30fps 기준 1틱 델타타임]) = 예시 정답 0.01666666666
                            //일반 애니메이션은 밑의 코드로 실행하면 애니메이션의 플레임이 나옵니다.
                            //1  / now_time 하면 전체 프레임이 나옵니다. 1로 정규화하였기때문입니다. 
                            //시간 별로 실행되는 애니메이션은 이 라인으로 넘기세요 실행시간을 지정하여 할수있습니다.(공격 모션등의 판정은 이 라인이 좋습니다.)

                            animator.SetFloat("play_time", now_time);
                        }
                       
                          
                     
                       
                        
                    }
                    else if (animator.gameObject.GetComponent<enemy_ai>() != null)
                    {
                        if (play_time_related_type == 1)
                        {

                            float calc_length = animator.gameObject.GetComponent<NPC_play_default_system>().get_now_ani_total_time() / pivot_length;//(0.5[애니메이션 시간 총길이를 변조할 값 여기서 0.363초 == 11 fps 0.363]/ 22fps 0.733 ) = 0.5
                            now_time += (Modulation * Time.deltaTime) / calc_length;

                            //이값들은 예제입니다.
                            //예제 (1(유니티 애니메이션 길이 기준 30fps)/(1.5[애니메이션 시간 총길이를 변조할 값 여기서 1.5초 == 45 fps]/ 1.3636363635 )) *0.03333333333[30fps 기준 1틱 델타타임]

                            //일반 애니메이션은 밑의 코드로 실행하면 애니메이션의 플레임이 나옵니다.
                            //1  / now_time 하면 전체 프레임이 나옵니다. 1로 정규화하였기때문입니다. 
                            //시간 별로 실행되는 애니메이션은 이 라인으로 넘기세요 실행시간을 지정하여 할수있습니다.(공격 모션등의 판정은 이 라인이 좋습니다.)

                            // (1.5 / 1.3636363635 ) = 1.10000000011 [길이 변환한거] / (30/22)  = 0.80666666674
                            if (now_time >= normalisze_pivot_length)
                            {
                                Debug.LogWarning("현재 기준 fps 점을 통과함.. 1");
                                //현재 기준 fps 점을 통과함..
                                if (!is_pass_to_pivot)
                                {
                                    //현재 기준 fps 점을 통과함..
                                   
                                    is_pass_to_pivot = true;
                                    animator.gameObject.GetComponent<enemy_ai>().animation_pass_to_pivot();
                                }
                            }
                            animator.SetFloat("play_time", now_time);

                        }
                        else
                        {
                            now_time += (1f / animator.gameObject.GetComponent<enemy_ai>().get_now_ani_total_time()) * Time.deltaTime;
                            //이값들은 예제입니다.
                            //(1 / 2[애니메이션 시간 총길이를 변조할 값 여기서 2초 == 60 fps] )*0.03333333333[30fps 기준 1틱 델타타임]) = 예시 정답 0.01666666666
                            //일반 애니메이션은 밑의 코드로 실행하면 애니메이션의 플레임이 나옵니다.
                            //1  / now_time 하면 전체 프레임이 나옵니다. 1로 정규화하였기때문입니다. 
                            //시간 별로 실행되는 애니메이션은 이 라인으로 넘기세요 실행시간을 지정하여 할수있습니다.(공격 모션등의 판정은 이 라인이 좋습니다.)

                            animator.SetFloat("play_time", now_time);
                        }
                      
                    }
                }
                else
                {
                   
                    now_time += (1f / stateInfo.length) * Time.deltaTime;
                    //(1( 1로 정규화 ) / 1.5[애니메이션 시간 총길이 == 45fps])*(0.03333333333[30fps 기준 1틱 델타타임]) = 1프레임 별 정규화된 델타 타임값 = 예시의 닶은 0.02222222222
                    //1/0.02222222222 = 45fps = 1.5length

                    animator.SetFloat("play_time", now_time);
                    
                }
                if (animator.gameObject.GetComponent<NPC_play_default_system>() != null)
                {
                    //if(animator.gameObject.GetComponent<NPC_play_default_system>().get_photonView().viewID == 1001)
                        //Debug.LogWarning("fps : " + frame);
                }
              
                frame++;

            }
            master_update(animator, stateInfo, layerIndex);
        }
       

    }

    // OnStateExit is called when a transition ends and the state machine finishes evaluating this state
    override public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {
        //
        // animator.GetFloat("play_time");
        if(PhotonNetwork.IsMasterClient)//애니메이션 끝나고 플레이 타임 0으로 교체함.
        {

           
            is_action = false;
            is_demage = false;
            animator.SetFloat("play_time", 0);
            now_time = 0;
            //real_fps = 0f;//실제 실행 시간을 알고 싶으면 주석처리를 해제하시오
            frame = 0;
        }
       
      
    }

    // OnStateMove is called right after Animator.OnAnimatorMove(). Code that processes and affects root motion should be implemented here
   // override public void OnStateMove(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {
        //
     
  //  }

    // OnStateIK is called right after Animator.OnAnimatorIK(). Code that sets up animation IK (inverse kinematics) should be implemented here.
    //override public void OnStateIK(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {
    //
    //}
}
