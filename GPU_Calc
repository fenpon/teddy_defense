


#pragma kernel ASTAR

struct Cel {
    int uid;
    int w;
    int x;
    int y;//w x y
    int t;
    int pbuid;//이전에 방문한 노드의 블록 uid
    int pi;//이전에 방문한 노드의 x (블록 범위안) x y -> 1차원 배열 인덱스로
   
};

struct Block_W {
    int uid;
    float sx;
    float sy;
  
    //int data[100];
};
struct Block_Data {
    int data;
    int pid;//해당 노드까지 오는 최단거리를 가진 이전 노드의볼록
    int pi;//해당 노드까지 오는 최단거리를 가진 이전 노드의 내부인덱스
};



struct Execute_Info
{
    int fin;
    int x;
    int y;
};
struct Heap {
    int w;
    int x;
    int y;
    int pbuid;//이전에 방문한 노드의 블록 uid
    int pi;//이전에 방문한 노드의 x (블록 범위안) x y -> 1차원 배열 인덱스로
};
RWStructuredBuffer<Heap> arr;//우선순위 큐 1차원 배열로 한거 각 인덱스별로 0: 0~ 119 , 1 : 120~ 239 , 2: 240~359 ..... 정적 변수로 클래스나 구조체안에서 선언하면 데이터 용량 한계랑 unroll정책때문에 이렇게 처리함
class Priority_Queue{//샘플링 할때 쓸 우선순위 큐 힙으로 구현
    //Heap arr[400];
    int pq_i;
    int max_size;
    int size;
    int pop_i;
    int get_start_i()
    {
        int start_i = pq_i * max_size;
        return start_i;
    }
    void Heapify(int i,uint ins)//i = index ,ins == 1 -> 삽입 ins == 2 -> 삭제 //재귀호출 dx에서 지원안함
    {
       // 왼쪽 자식의 인덱스 = (부모의 인덱스) * 2
           // 오른쪽 자식의 인덱스 = (부모의 인덱스) * 2 + 1
           // 부모의 인덱스 = (자식의 인덱스) / 2
        if (ins == 1)//삽입
        {
            int now = i;
          
            
           // [unroll(4)]//컴파일러 옵션 반복 확인 1번만해서 풀도록함
            
            while (now >= 1)//깊이만큼 고정 탐색을 정하는데 중간에 조건 맞으면 멈춘다 unroll 정책땜에 무조건 고정 수치를 루프해야한다
            {
                
                 
                int par = now / 2;
             
                if (arr[get_start_i()+par].w > arr[get_start_i()+now].w)
                {
                    Heap tmp = arr[get_start_i() + now];
                    arr[get_start_i() + now] = arr[get_start_i() + par];
                    arr[get_start_i() + par] = tmp;
                    now = par;
                    continue;
                }
                
                    break;
                
               


            }
        }
        else//삭제
        {
           // int now = i;

           
           
            while (i <= size)//깊이만큼 고정 탐색을 정하는데 중간에 조건 맞으면 멈춘다 unroll 정책땜에 무조건 고정 수치를 루프해야한다
            {
               
             
                int L = i * 2;
                int R = (i * 2)+1;

                
                if (arr[get_start_i() + L].w == 0 && arr[get_start_i() + R].w == 0)
                {
                    break;
                }
                int Lv = arr[get_start_i() + L].w;
                int Rv = arr[get_start_i() + R].w;
                if (Lv == 0 || L >= size)
                {
                    Lv = 99999999;
                }
                if (Rv == 0 || R >= size)
                {
                    Rv = 99999999;
                }
                if (arr[get_start_i() + i].w > Lv && arr[get_start_i() + i].w > Rv)//둘다 교체가능할땐 더작은값과 교체
                {
                    if(arr[get_start_i() + L].w < arr[get_start_i() + R].w)//l
                    {
                        Heap tmp1 = arr[get_start_i() + i];
                        arr[get_start_i() + i] = arr[get_start_i() + L];
                        arr[get_start_i() + L] = tmp1;
                        i = L;
                        continue;
                    }
                    else
                    {
                        Heap tmp2 = arr[get_start_i() + i];
                        arr[get_start_i() + i] = arr[get_start_i() + R];
                        arr[get_start_i() + R] = tmp2;
                        i = R;
                        continue;
                    }
                 

                }
                else if (arr[get_start_i() + i].w > Lv)//l
                {
                    Heap tmp3 = arr[get_start_i() + i];
                    arr[get_start_i() + i] = arr[get_start_i() + L];
                    arr[get_start_i() + L] = tmp3;
                    i = L;
                    continue;
                }
                else if (arr[get_start_i() + i].w > Rv)//r
                {
                    Heap tmp4 = arr[get_start_i() + i];
                    arr[get_start_i() + i] = arr[get_start_i() + R];
                    arr[get_start_i() + R] = tmp4;
                    i = R;
                    continue;
                }
             
                break;
                
                


            }
        }
      
    }
   
    int push(int w,int x,int y,int puid,int pi)
    {
       
   
        if (size < max_size)
        {
            Heap ln;
            ln.w = w;
            ln.x = x;
            ln.y = y;
            ln.pbuid = puid;
            ln.pi = pi;
           
            
            size++;
            arr[get_start_i() + size-1] = ln;
            Heapify(size - 1, 1);
        }
        return size;
    }
    int pop()
    {
        size = min(size, max_size);
        if (size > 1)
        {
           
            pop_i++;
            arr[get_start_i()+1] = arr[get_start_i() +  size-1 ];
            arr[get_start_i() +size - 1].w = 0;
            arr[get_start_i() + size - 1].x = 0;
            arr[get_start_i() + size - 1].y = 0;
            arr[get_start_i() + size - 1].pbuid = -1;
            arr[get_start_i() + size - 1].pi = -1;
            size = size - 1;
           
            Heapify(1, 2);
        }
        return size;
    }
   
};
struct Finish
{
    int flag;
};


RWStructuredBuffer<Finish> E;//목적지 좌표저장
RWStructuredBuffer<Finish> finish;//경로를 다찾았는지
RWStructuredBuffer<Cel> ln;//탐색시 사용할  pATH의 우선순위 큐의 최소힙 즉 heap[1]의 블록을 넣는다

//uint D[10500];//블록으로 블록의 시작 x y 0 1 하고 체크할 좌표들의 맵핑값 2~101
RWStructuredBuffer<Block_W> D;// 100개짜리 좌표를 확인하고 100개의 셀이 작동하니까 100블록으로 나눔
RWStructuredBuffer<Block_Data> BD;// 100개짜리 좌표를 확인하고 100개의 셀이 작동하니까 100블록으로 나눔


RWStructuredBuffer<Execute_Info> info;//gpu 셀의 실행 정보를 저장함

//D를 참조하면서 경로탐색을하다 해당 찾는 인덱스의 D블록이 없으면 cpu에서 줄때 까지 대기하고 다음 cpu프레임때 command버퍼에 넣어 요청하도록하자
//block을 cpu에 요청할땐 해당 요청한 셀(코어)는 락걸고 기다린다.

RWStructuredBuffer<Cel> outer;//w x y   다음 탐색할 노드 저장

//RWStructuredBuffer<int> result;//65000만개이상 못씀 // 100개짜리 좌표를 확인하고 100개의 셀이 작동하니까 100블록으로 나눔

// Three vertices define a triangle in space




int Get_Block_index(int find_id)//현재 위치가 포함된 블록의 인덱스를 찾는다 블록은 cpu에서 연결리스트의 스케줄러에서 관리하는데 100번째 인덱스의 uid를 통해 찾아낸다
{
    int Block_i = -1;
    int bi = 0;
    
    for (int i = 0; i < 900; ++i)
    {

        if (BD[(i * 103) + 100].data == find_id)
        {
            Block_i = (i * 103);
            break;
        }
     
      
        //i += 103;
    }
    return Block_i;
}
int Get_Block_Pos(int xx,int yy)//블록 좌표 x,y축을 구하고 이를 1차원 배열의 인덱스로 변경
{
    int bx = xx % 10;
    int by = yy % 10;
 
    int res = (by * 10) + bx;
    return res;
}
int Get_Uid(int x,int y)//블록의 식별자 찾기 xy좌표를 귀준으로 2차배열인덱스를 1차배열 인덱스로만듬
{
    int res = -1;
    int bx = x / 10;
    int by = y / 10;

   
    res = ((by * 100) + bx)+1;
    return  res;

}
Heap make_heap(int w,int x,int y)
{
    Heap res;
    
    res.w = w;
    res.x = x;
    res.y = y;

    return res;
}
bool range(int x,int y)//범위내의 좌표인지
{
    return (x >= 0 && x < 1000 && y >= 0 && y < 1000);
    //return true;
}
[numthreads(10, 10, 1)]// -> 10*10*1 = 100의 갯수의 셀에서 실행
void ASTAR(uint3 id : SV_DispatchThreadID)//10, 10, 1 100개의 쓰레드만 연다 
{

    int now_index =  id.x + (id.y*10) + 1;
    int dx[4] = { 1,0,-1,0 };
    int dy[4] = { 0,1,0,-1 };

    //info[now_index].fin = BD[((now_index-1)*103) + 100].data;
    
    info[now_index].fin = 0;
    if (ln[now_index].w > 0)
    {
       
        int next_node_count = 1;
       
        int sBlock_i = Get_Block_index(ln[now_index].uid);//블록의 위치를가르키는 인덱스
        int starnsform_Block_i = Get_Block_Pos(ln[now_index].x, ln[now_index].y);//블록내에서 사용하는 인덱스
        
        
        //if (BD[sBlock_i + starnsform_Block_i].data > ln[now_index].w || BD[sBlock_i + starnsform_Block_i].data == 0)//현재 노드가 탐색아예안한곳 0 이거나 이전에 탐색한 범위보다 적은 가중치일때만 실행
       
            int sbx = BD[sBlock_i + 101].data;
            int sby = BD[sBlock_i + 102].data;
            //outer0[now_index].w = ln[now_index].uid;


            int suid = Get_Uid(ln[now_index].x, ln[now_index].y);//시작 블록 아이디
            
            if (finish[0].flag != 1)
            {


                if (suid > 0)//uid가 블록 버퍼안에 있다.
                {

                    // info[now_index].fin = ln[now_index].uid;

                     //outer0[now_index].x = Get_Uid(ln[now_index].x, ln[now_index].y);
                    // outer0[now_index].y = sby;
                 
                    if (sBlock_i < 0)//블록없음 아직 안왔으므로 다시 gpu대기열 힙에올리기 위해 등록
                    {
                        //info[now_index].fin = now.w;//uid;
                       // info[now_index].x = now.x;
                        //info[now_index].y = now.y;

                        Cel out_v;

                        out_v.w = ln[now_index].w;
                        out_v.x = ln[now_index].x;
                        out_v.y = ln[now_index].y;
                        out_v.pbuid = ln[now_index].pbuid;
                        out_v.pi = ln[now_index].pi;
                        out_v.t = 7;
                        out_v.uid = ln[now_index].uid;
                        outer[(now_index - 1) * 101 + next_node_count] = out_v;
                        //outer.Append(out_v);
                        next_node_count++;

                      


                    }
                    else
                    {
                   
                        //if ((BD[sBlock_i + starnsform_Block_i].data != -1 && BD[sBlock_i + starnsform_Block_i].data > ln[now_index].w) || BD[sBlock_i + starnsform_Block_i].data == 0)
                       // if (BD[sBlock_i + starnsform_Block_i].data == 0)
                     
                        
                            if (BD[sBlock_i + starnsform_Block_i].data == 0)
                            {

                                // ppq[1] = make_heap(ln[now_index].w, ln[now_index].x, ln[now_index].y);

                                BD[sBlock_i + starnsform_Block_i].data = 1;
                                BD[sBlock_i + starnsform_Block_i].pid = ln[now_index].pbuid;
                                BD[sBlock_i + starnsform_Block_i].pi = ln[now_index].pi;

                              


                                Priority_Queue pq;
                                pq.pq_i = now_index;//우선순위 큐의 인덱스이다
                                pq.max_size = 120;//우선순위 큐의 최대 크기
                                pq.pop_i = 1;
                           
                                pq.size = 1;
                                pq.push(ln[now_index].w, ln[now_index].x, ln[now_index].y, ln[now_index].pbuid, ln[now_index].pi);



                                int C = 0;
               
                                int nc = 1;
                                while (pq.size > 1)
                                {
                                    //info[now_index].fin = 1;//uid;
                                    C++;

                                    if (C >= 500)//절대 10*10 * 4의 루프를 벗어나지 않는다.
                                    {
                                        break;
                                    }

                                    //break;
                                    Heap now = arr[pq.get_start_i() + 1];
                                    pq.pop();
                                   

                                    if (finish[0].flag == 1)
                                    {
                                        break;
                                    }
                                    int uid = Get_Uid(now.x, now.y); //블록 식별자



                                    int Block_i = Get_Block_index(uid);

                                    if (Block_i < 0)//블록없음 아직 안왔으므로 다시 gpu대기열 힙에올리기 위해 등록
                                    {
                                        //info[now_index].fin = now.w;//uid;
                                       // info[now_index].x = now.x;
                                        //info[now_index].y = now.y;
                                        /**/
                                        Cel out_v;

                                        out_v.w = now.w;
                                        out_v.x = now.x;
                                        out_v.y = now.y;
                                        out_v.t = 9;
                                        out_v.uid = uid;
                                        out_v.pbuid = now.pbuid;
                                        out_v.pi = now.pi;
                                        outer[(now_index - 1) * 101 + next_node_count] = out_v;
                                        //outer.Append(out_v);
                                        next_node_count++;

                                        continue;


                                    }



                                    int tarnsform_Block_i = Get_Block_Pos(now.x, now.y);//블록내에서 사용하는 인덱스

                                    if (BD[Block_i + tarnsform_Block_i].data == -1)
                                    {
                                        continue;
                                    }


                                  





                                    //  BD[Block_i + tarnsform_Block_i].data = 1;

                                      // BD[Block_i + tarnsform_Block_i].data = 1;



                                        //outer0[C].w = now.w;
                                        //   outer1[C].w = now.x;
                                         //  outer2[C].w = now.y;
                                      // outer0[now_index].x = Block_i + tarnsform_Block_i;
                                       //pq.push(now, heap_size);
                                       //range작업


                                    for (int i = 0; i < 4; i++)
                                    {

                                        int nx = now.x + dx[i];
                                        int ny = now.y + dy[i];
                                        int nw = (int)(abs(E[0].flag - nx) + abs(E[1].flag - ny) + 1);
                                        //if (!range(nx, ny))
                                           // continue;


                                        //C++;
                                        //outer0[C].w = nw;
                                       // outer1[C].w = nx;
                                        //outer2[C].w = ny;
                                        int nid = Get_Uid(nx, ny); //블록 식별자


                                        int nBlock_i = Get_Block_index(nid);

                                        int ntarnsform_Block_i = Get_Block_Pos(nx, ny);//블록내에서 사용하는 인덱스



                                        if (nBlock_i < 0)
                                        {

                                            Cel out_v;
                                            out_v.w = nw;
                                            out_v.x = nx;
                                            out_v.y = ny;
                                            out_v.t = 10;
                                            out_v.uid = nid;
                                            out_v.pbuid = uid;
                                            out_v.pi = tarnsform_Block_i;
                                            outer[(now_index - 1) * 101 + next_node_count] = out_v;//이거 쓰고안지워서 이전에 기록이 남아서 실행이 안되도 데이터있어서 버그남
                                            //outer.Append(out_v);
                                            next_node_count++;

                                            continue;
                                        }
                                        if (BD[nBlock_i + ntarnsform_Block_i].data == 0)
                                        {
                                          
                                            if (nid == suid)//같은  블록에 있는지
                                            {
                                                // BD[sBlock_i + starnsform_Block_i].data = 1;

                                                 // BD[nBlock_i + ntarnsform_Block_i].data = 1;
                                                if (BD[Block_i + tarnsform_Block_i].pi == ntarnsform_Block_i)
                                                {
                                                    continue;
                                                }
                                                if (BD[nBlock_i + ntarnsform_Block_i].pi == tarnsform_Block_i)//순환확인
                                                {
                                                   // continue;
                                                }
                                                BD[nBlock_i + ntarnsform_Block_i].data = 1;

                                                BD[nBlock_i + ntarnsform_Block_i].pid = uid;//이전경로 값 저장
                                                BD[nBlock_i + ntarnsform_Block_i].pi = tarnsform_Block_i;//이전경로 값 저장

                                                if (nx == E[0].flag && ny == E[1].flag)//Fin
                                                {
                                                    finish[0].flag = 1;
                                                    //정답 찾아서 최종결과 넣음 t 옵션으로 완료 여부확인
                                                    Cel out_v;
                                                    out_v.w = nw;
                                                    out_v.x = nx;
                                                    out_v.y = ny;
                                                    out_v.t = 1;
                                                    out_v.uid = nid;
                                                    out_v.pbuid = uid;
                                                    out_v.pi = tarnsform_Block_i;
                                                    outer[(now_index - 1) * 101 + next_node_count] = out_v;//이거 쓰고안지워서 이전에 기록이 남아서 실행이 안되도 데이터있어서 버그남

                                                   // BD[nBlock_i + ntarnsform_Block_i].data = 1;
                                                    //BD[nBlock_i + ntarnsform_Block_i].pid = uid;//이전경로 값 저장
                                                    //BD[nBlock_i + ntarnsform_Block_i].pi = tarnsform_Block_i;//이전경로 값 저장

                                                    //outer.Append(out_v);
                                                    next_node_count++;
                                                    pq.size = 1;
                                                    break;
                                                }
                                                // info[nc].fin = nw;
                                                nc++;

                                                pq.push(nw, nx, ny, uid, tarnsform_Block_i);



                                            }
                                            else//다른 블록의 노드들 다음에 cpu에서 우선순위 연산하고 gpu에서 우선순위에맞게 연산한다
                                            {


                                                if ((abs(suid - nid) == 1 || abs(suid - nid) == 100))//인접 블록만 다음 노드 넣는다
                                                {
                                                    //info[now_index].fin = now.w;
                                                   

                                                        Cel out_v;
                                                        out_v.w = nw;
                                                        out_v.x = nx;
                                                        out_v.y = ny;
                                                        out_v.t = 17;
                                                        out_v.uid = nid;
                                                        out_v.pbuid = uid;
                                                        out_v.pi = tarnsform_Block_i;

                                                        // BD[nBlock_i + ntarnsform_Block_i].data = 1;
                                                        // BD[nBlock_i + ntarnsform_Block_i].pid = uid;//이전경로 값 저장
                                                         // BD[nBlock_i + ntarnsform_Block_i].pi = tarnsform_Block_i;//이전경로 값 저장



                                                        outer[(now_index - 1) * 101 + next_node_count] = out_v;//이거 쓰고안지워서 이전에 기록이 남아서 실행이 안되도 데이터있어서 버그남
                                                        //outer.Append(out_v);
                                                        next_node_count++;

                                                    

                                                }


                                            }
                                        }


                                    }



                                }

                                //해당 노드를 통해 블록에 들어왔고 여기서 루프 멈추고 다음 블록을 연결하여 경로를 최종 완성함

                            }
                        
                     
                    }

                }
                else
                {
                    
                    Cel out_v;
                    out_v.w = ln[now_index].w;
                    out_v.x = ln[now_index].x;
                    out_v.y = ln[now_index].y;
                    out_v.t = 2;
                    out_v.uid = ln[now_index].uid;
                    out_v.pbuid = ln[now_index].pbuid;
                    out_v.pi = ln[now_index].pi;
                    outer[(now_index - 1) * 101 + next_node_count] = out_v;//이거 쓰고안지워서 이전에 기록이 남아서 실행이 안되도 데이터있어서 버그남
                 
                    //outer.Append(out_v);
                    next_node_count++;
                    
                }
            }
            
            //info[now_index].fin = C;
            //outer0[now_index].w = C;
            //outer0[now_index].x = arr[pq.get_start_i()+1].w;
            //outer0[now_index].y = arr[pq.get_start_i()+2].w;
        
        
    }
    info[now_index].fin = 1;
  
}
